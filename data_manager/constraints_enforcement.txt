This project is very dynamic in the formsets its presenting on the admin pages. This implies a need for custom validation of the constraints, to protect against (in increasing order of interest):
* Bugs in the code
* Forged forms submission

= Enforcing Specific on Release and Occurrence =
1.a) There must be a formset for each Specific corresponding to the nature(s) of the instance (the instance being a Release or an Occurrence).
1.b) There must not be any formset for a Specific that is not corresponding to the nature(s).
This is naturally enforced by the dynamic generation of FormSet_set in the server code: this code create all the required formset, and only those formsets.
In particular for b), even if data was posted for other formsets, it would not be assigned to anything.

2) In each Specific's formset, there must be exactly ONE form
This is enforced by min_num = max_num = 1 and validate_min + validate_max, which are set on each Specific's formset instance.

It appears there is no need for custom validation to enforce the correct Specific composition.

= Constraints on Release attributes =
1) When the same Attribute is repeated for a given Release, each must have a distinct note. (Nb: empty being distinct from any non-empty) It applies to both Attribute and CustomAttribute
Interface: this should be natively enforced by Django models, relying on unique_together constraint.
Offline: Trivial check using the query API

= Enforcing the Attributes assigned to Occurrences=
1.a) For any Occurrence, there must be one and only one OccurrenceAttribute instance mapping to each ReleaseAttribute of its correponding Release.
1.b) There must not be an OccurrenceAttribute without the corresponding ReleaseAttribute on the Release.
1.c) The value assigned to the OccurrenceAttribute must be a value authorized by the corresponding ReleaseAttribute type.

= Enforcing the Releases and Occurrences composition =
1) Prevent circular compositions on Release (release A is composed of a release B which is composed of a release A)
2.1) For any occurrence, the candidates for nesting correspond to the corresponding Release composition.
3) Any occurrence can only be nested in a single occurrence
    This is enforced at the model level, OccurrenceComposition::to_occurrence being marked unique
3.1)also: remove them from the candidate queryset once nested in another occurence
    exception: immaterials (idea of implicitly making an immaterial occurence of each game release or concept ? unclear)
    NO EXCEPTION ANYMORE: we instantiate immaterials for composition the same way than for materials
4) For an occurrence, there must be exactly one OccurrenceComposition instance (potentially empty) for each ReleaseComposition instance of the corresponding Release.
4.1) Ideally, enforce same order (pk ordering I guess ?)

= Special Concepts =
1) The special Concepts ("combo" at the moment) are assigned a primary nature of the same name. Only one Concept instance can be assigned those special nature.


= Immaterial restrictions =
1) Prevent an immaterial release from having: attribute, custom attributes, or nested releases.
2) For an immaterial release, the material fields must be left blank (ex: "loose", "barcode").
3) An occurrence that instantiate an immaterial release must be nested under antother occurrence, that cannot be immaterial.

= User management =
1) The created_by field should not be allowed to change
2.a) There should be a TagToOccurrence instance for each Occurrence
2.b) and only one
    2.b is naturally enforced by the occurrence OneToOneField.


= Tweaking the Admin interface to fit the application =

* Removing the '+' sign on formsets (allowing to add more forms)
** set the FormSet class 'max_num' attribute to the number of displayed forms.

* Removing the 'delete' checkbox on formset forms
** set the AdminInline class 'can_delete' attribute to false. 


